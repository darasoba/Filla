<!DOCTYPE html>
<html>
  <head>
    <style>
      :root {
        --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        
        /* Light Theme (default) - Updated for cohesion */
        --bg-color: #FFFFFF;
        --text-color: #333333;
        --text-color-muted: #666666;
        --primary-button-bg: #FF2D55; /* Brand color */
        --primary-button-text: #FFFFFF;
        --secondary-button-bg: #FFFFFF; /* White background */
        --secondary-button-text: #101010; /* Dark text */
        --border-color: #101010; /* Dark border */
        --steps-bg: #F0F0F0;
        --steps-text-color: #101010;
        --steps-border-color: #E5E5E5;
        
        /* Message colors slightly adjusted for harmony */
        --message-success-bg: #E3F5E9;
        --message-success-text: #1E7F4C;
        --message-error-bg: #FFEBEE;
        --message-error-text: #C62828;
        --message-info-bg: #E3F2FD;
        --message-info-text: #1565C0;
      }

      html.figma-dark {
        /* Dark Theme - Updated for cohesion */
        --bg-color: #2C2C2C;
        --text-color: #E0E0E0;
        --text-color-muted: #AAAAAA;
        --primary-button-bg: #FF2D55; /* Brand color */
        --primary-button-text: #FFFFFF;
        --secondary-button-bg: #1E1E1E; /* Dark background */
        --secondary-button-text: #FFFFFF; /* White text */
        --border-color: #FFFFFF; /* White border */
        --steps-bg: #383838;
        --steps-text-color: #E0E0E0;
        --steps-border-color: #555555;
        /* Message colors adjusted for dark mode */
        --message-success-bg: #1E7F4C;
        --message-success-text: #E3F5E9;
        --message-error-bg: #C62828;
        --message-error-text: #FFEBEE;
        --message-info-bg: #1565C0;
        --message-info-text: #E3F2FD;
      }

      body {
        font-family: var(--font-family);
        margin: 0;
        padding: 24px; /* Increased padding */
        background-color: var(--bg-color);
        color: var(--text-color);
        overflow: auto;
        font-size: 14px;
        line-height: 1.6; /* Improved line height */
        transition: background-color 0.3s, color 0.3s; /* Smooth theme transition */
      }
      
      h2 {
        margin-top: 0;
        margin-bottom: 12px; /* Added bottom margin */
        color: var(--text-color);
        font-size: 20px; /* Slightly larger */
        font-weight: 600; /* Bolder */
      }
      
      p {
        color: var(--text-color-muted);
        line-height: 1.5;
        margin-bottom: 16px; /* Added bottom margin */
      }
      
      .button-container {
        display: flex;
        flex-direction: row;
        gap: 10px;
        margin-top: 20px;
        width: 100%; /* Fill the container width */
      }
      
      /* When only one button is visible, it should take full width */
      .button-container:has(.button-tooltip-wrapper:only-child) .button-tooltip-wrapper {
        width: 100%;
      }
      
      .button-container:has(button:only-child) button {
        width: 100%;
      }
      
      button {
        border: 1px solid transparent;
        border-radius: 8px;
        padding: 12px 18px;
        cursor: pointer;
        font-weight: 500;
        transition: background-color 0.2s, opacity 0.2s, border-color 0.2s;
        text-align: center;
        display: block;
        width: 100%; /* Each button fills its flex space */
        box-sizing: border-box;
      }
      
      button:focus {
        outline: none;
      }
      
      .primary-button:focus {
        box-shadow: 0 0 0 2px var(--primary-button-bg); /* Focus ring only for primary button */
      }
      
      button:hover {
        opacity: 0.85; /* Slightly adjusted hover */
      }
      
      .primary-button {
        background-color: var(--primary-button-bg);
        color: var(--primary-button-text);
      }
      
      .secondary-button {
        background-color: var(--secondary-button-bg);
        color: var(--secondary-button-text);
        border: 1px solid var(--border-color); /* Added border for definition */
      }

      .secondary-button:hover {
        background-color: #FFEEF1; /* Light gray hover for light mode */
        border-color: #FFDFE5;
      }
      
      html.figma-dark .secondary-button:hover {
        background-color: #4A1F26; /* Dark pink-tinted background for dark mode */
        border-color: #662A33; /* Darker pink border for dark mode */
      }
      
      .message {
        margin-top: 20px; /* Adjusted margin */
        margin-bottom: 20px; /* Adjusted margin */
        padding: 14px;    /* Increased padding */
        border-radius: 8px; /* Consistent rounding */
        font-size: 13px;
        line-height: 1.4;
      }
      
      .success {
        background-color: var(--message-success-bg);
        color: var(--message-success-text);
      }
      
      .error {
        background-color: var(--message-error-bg);
        color: var(--message-error-text);
      }
      
      .info {
        background-color: var(--message-info-bg);
        color: var(--message-info-text);
      }
      
      .hidden {
        display: none !important; /* Added !important to ensure it overrides */
        visibility: hidden !important; /* Double ensure with visibility */
      }
      
      .steps {
        background-color: var(--steps-bg);
        padding: 16px; /* Increased padding */
        border-radius: 8px; /* Consistent rounding */
        margin-bottom: 20px; /* Adjusted margin */
        border: 1px solid var(--steps-border-color); /* Subtle border */
      }
      
      .steps ol {
        margin: 0;
        padding-left: 20px;
        color: var(--steps-text-color); /* Use the new variable */
      }
      
      .steps li {
        margin-bottom: 8px;
        font-size: 13px; /* Slightly smaller for steps */
      }

      .steps li:last-child {
        margin-bottom: 0; /* Remove bottom margin from last item */
      }

      /* Styles for disabled buttons */
      button:disabled,
      button.primary-button:disabled {
        background-color: #CCCCCC; /* Light gray background for disabled state in light mode */
        color: #777777; /* Darker gray text for better contrast */
        border-color: transparent; /* No border */
        cursor: not-allowed; /* Indicate non-interactive state */
        opacity: 1; /* Full opacity with muted colors */
      }
      
      button.secondary-button:disabled {
        background-color: #F0F0F0; /* Very light gray background */
        color: #AAAAAA; /* Medium gray text */
        border-color: #DDDDDD; /* Light gray border */
        cursor: not-allowed;
      }
      
      html.figma-dark button:disabled,
      html.figma-dark button.primary-button:disabled {
        background-color: #444444; /* Dark gray for dark mode */
        color: #888888; /* Medium gray text */
      }
      
      html.figma-dark button.secondary-button:disabled {
        background-color: #333333; /* Dark gray background */
        color: #777777; /* Medium gray text */
        border-color: #444444; /* Slightly lighter border */
      }

      /* Disabled buttons don't need hover effects */

      /* Tooltip styles */
      .button-tooltip-wrapper {
        position: relative;
        display: flex; /* Make the wrapper a flex container/item itself */
        width: 100%; /* Make tooltip wrapper take full width */
        flex-grow: 1; /* Always allow it to grow */
        /* flex-grow is set by JS, making this wrapper expand in button-container */
      }

      .button-tooltip-wrapper:has(> button#extract-button:disabled):hover::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 105%; /* Position above the wrapper */
        left: 50%;
        transform: translateX(-50%);
        background-color: #333333; /* Dark background for tooltip */
        color: #FFFFFF; /* Light text for tooltip */
        padding: 6px 10px;
        border-radius: 4px;
        font-size: 12px;
        white-space: nowrap;
        z-index: 1000; /* Ensure it's above other elements */
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        pointer-events: none; /* Tooltip itself should not capture mouse events */
      }

      /* Optional: Tooltip arrow */
      .button-tooltip-wrapper:has(> button#extract-button:disabled):hover::before {
        content: "";
        position: absolute;
        bottom: 100%; 
        left: 50%;
        transform: translateX(-50%) translateY(5px); /* Position arrow slightly overlapping/below the tooltip body's bottom */
        border-width: 5px;
        border-style: solid;
        border-color: #333333 transparent transparent transparent; /* Arrow pointing up, matches tooltip bg */
        z-index: 1000;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <h2>Color Palette Extractor</h2>
    
    <div id="message" class="message hidden"></div>
    
    <div class="steps">
      <ol>
        <li>Select a parent frame in your Figma workspace</li>
        <li>Click "Extract Colors" to analyze all layers inside</li>
        <li>A new frame with your color palette will be created</li>
        <li>Extracts both solid colors and complete gradients</li>
      </ol>
    </div>
    
    <div class="button-container">
      <span id="extract-button-wrapper" class="button-tooltip-wrapper" data-tooltip="Please select an object on your canvas.">
        <button id="extract-button" class="primary-button" disabled>Extract Colors</button>
      </span>
      <button id="create-styles-button" class="secondary-button" style="display: none;">Create Styles</button>
      <!-- <button id="cancel-button" class="secondary-button">Cancel</button> -->
    </div>
    
    <script>
      // Variables to store the extracted colors
      let extractedColors = [];
      let messageTimeout; // Variable to store the timeout ID
      let buttonCheckInterval; // Variable to store the interval ID for button checks
      
      // Button references
      const extractButtonWrapper = document.getElementById('extract-button-wrapper'); // Get the wrapper
      const extractButton = document.getElementById('extract-button');
      const createStylesButton = document.getElementById('create-styles-button');
      const cancelButton = document.getElementById('cancel-button');
      const messageElement = document.getElementById('message');
      
      // Function to show a message to the user
      function showMessage(text, type) {
        messageElement.textContent = text;
        messageElement.className = `message ${type}`; // This makes it visible
        messageElement.classList.remove('hidden'); // Ensure it's visible

        // Clear any existing timeout
        if (messageTimeout) {
          clearTimeout(messageTimeout);
        }

        // Set a timeout to hide the message after 5 seconds
        messageTimeout = setTimeout(() => {
          messageElement.classList.add('hidden');
        }, 5000);
      }
      
      // Function to ensure the create styles button is visible and working
      function showCreateStylesButton(colors) {
        console.log('UI.HTML: Attempting to show Create Styles button with multiple methods');
        extractedColors = colors || [];
        
        // Try all known methods to make the button visible
        if (createStylesButton) {
          createStylesButton.classList.remove('hidden');
          createStylesButton.style.display = 'block';
          createStylesButton.style.visibility = 'visible';
          createStylesButton.disabled = false;
        } else {
          console.log('UI.HTML: Create Styles button not found, creating a new one');
          
          // Create a new button if the original is somehow not accessible
          const buttonContainer = document.querySelector('.button-container');
          if (buttonContainer) {
            // Remove old button if it exists but is inaccessible
            const oldButton = document.getElementById('create-styles-button');
            if (oldButton) buttonContainer.removeChild(oldButton);
            
            // Create and append new button
            const newButton = document.createElement('button');
            newButton.id = 'create-styles-button';
            newButton.className = 'secondary-button';
            newButton.textContent = 'Create Color Styles';
            newButton.style.display = 'block';
            
            // Add event listener
            newButton.addEventListener('click', () => {
              showMessage('Creating color styles...', 'info');
              parent.postMessage({ 
                pluginMessage: { 
                  type: 'create-styles',
                  colors: JSON.stringify(extractedColors)
                } 
              }, '*');
            });
            
            buttonContainer.appendChild(newButton);
            createStylesButton = newButton; // Update the reference
          }
        }
        
        console.log('UI.HTML: Button visibility status:', 
                   createStylesButton.style.display,
                   createStylesButton.style.visibility,
                   !createStylesButton.classList.contains('hidden'));
        updateButtonLayout(); // Update layout after showing button
      }

      // Function to update button layout based on visibility
      function updateButtonLayout() {
        const isCreateStylesVisible = createStylesButton && 
                                      createStylesButton.style.display !== 'none' && 
                                      !createStylesButton.classList.contains('hidden');
        if (extractButtonWrapper) { // Target the wrapper for flexGrow
          if (isCreateStylesVisible) {
            extractButtonWrapper.style.flexGrow = '1';
            if (createStylesButton) createStylesButton.style.flexGrow = '1';
          } else {
            extractButtonWrapper.style.flexGrow = '1';
            extractButtonWrapper.style.width = '100%'; // Ensure full width when alone
            if (createStylesButton) createStylesButton.style.flexGrow = '0';
          }
        }
      }
      
      // Initialize buttons and elements when the page loads
      document.addEventListener('DOMContentLoaded', () => {
        console.log('UI.HTML: DOM fully loaded, initializing elements');
        
        // Ensure the extract button wrapper is full width initially
        if (extractButtonWrapper) {
          extractButtonWrapper.style.width = '100%';
          extractButtonWrapper.style.flexGrow = '1';
        }
        
        // Ensure create-styles-button exists or create it if it doesn't
        if (!document.getElementById('create-styles-button')) {
          console.log('UI.HTML: Create Styles button not found at load, creating one');
          const buttonContainer = document.querySelector('.button-container');
          
          if (buttonContainer) {
            const newButton = document.createElement('button');
            newButton.id = 'create-styles-button';
            newButton.className = 'secondary-button hidden';
            newButton.textContent = 'Create Color Styles';
            newButton.style.display = 'none';
            
            newButton.addEventListener('click', () => {
              console.log('UI.HTML: Create Styles button clicked');
              showMessage('Creating color styles...', 'info');
              parent.postMessage({ 
                pluginMessage: { 
                  type: 'create-styles',
                  colors: JSON.stringify(extractedColors)
                } 
              }, '*');
            });
            
            buttonContainer.appendChild(newButton);
            createStylesButton = newButton;
          }
        } else {
          console.log('UI.HTML: Create Styles button found at load, ensuring hidden');
          createStylesButton = document.getElementById('create-styles-button');
          createStylesButton.classList.add('hidden');
          createStylesButton.style.display = 'none';
        }
        
        // Log the initial state of the button
        console.log('UI.HTML: Initial button state:', createStylesButton ? 
                   `display=${getComputedStyle(createStylesButton).display}, 
                    visibility=${getComputedStyle(createStylesButton).visibility}` : 
                   'button not found');
        updateButtonLayout(); // Set initial layout
      });
      
      // Add event listeners
      extractButton.addEventListener('click', () => {
        // Reset any previous messages
        messageElement.classList.add('hidden');
        if (createStylesButton) { // Check if createStylesButton exists
          createStylesButton.classList.add('hidden'); // Ensure it's hidden
          createStylesButton.style.display = 'none'; // Explicitly hide
          createStylesButton.disabled = true; // And disabled
        }
        
        // showMessage('Sending extract-colors request...', 'info');
        // messageElement.classList.remove('hidden');
        
        // Tell the plugin to extract colors
        parent.postMessage({ pluginMessage: { type: 'extract-colors' } }, '*');
        updateButtonLayout(); // Update layout after hiding button
      });
      
      if (createStylesButton) { // Check if createStylesButton exists before adding listener
        createStylesButton.addEventListener('click', () => {
          // showMessage('Sending create-styles request...', 'info');
          // messageElement.classList.remove('hidden');
          
          // Tell the plugin to create color styles
          parent.postMessage({ 
            pluginMessage: { 
              type: 'create-styles',
              colors: JSON.stringify(extractedColors)
            } 
          }, '*');
        });
      }
      
      if (cancelButton) {
        cancelButton.addEventListener('click', () => {
          parent.postMessage({ pluginMessage: { type: 'cancel' } }, '*');
        });
      }
      
      // Listen for messages from the plugin
      window.onmessage = (event) => {
        console.log('UI.HTML: Message received in UI:', event.data);
        
        try {
          // Figma plugin messages come in event.data.pluginMessage
          const message = event.data.pluginMessage;
          
          if (!message) {
            console.log('UI.HTML: No pluginMessage in event.data');
            return;
          }
          
          console.log('UI.HTML: Processing message type:', message.type, 'Payload:', message);
  
          if (message.type === 'success') {
            showMessage(message.message, 'success');
            
            // Use multiple conditions to robustly check if we should show the button
            console.log('UI.HTML: Checking paletteExtracted flag:', message.paletteExtracted);
            
            // If the success was for extracting colors, show and enable the create styles button
            if (message.paletteExtracted === true || 
                (message.message && message.message.includes('palette')) || 
                (message.colors && message.colors.length > 0)) { 
              console.log('UI.HTML: Showing Create Styles button based on conditions');
              showCreateStylesButton(message.colors);
              
              // Set a backup interval to check if button is visible
              if (buttonCheckInterval) {
                clearInterval(buttonCheckInterval);
              }
              
              buttonCheckInterval = setInterval(() => {
                const buttonVisible = createStylesButton && 
                  (getComputedStyle(createStylesButton).display !== 'none' && 
                   getComputedStyle(createStylesButton).visibility !== 'hidden');
                
                if (!buttonVisible) {
                  console.log('UI.HTML: Button not visible in interval check, trying again');
                  showCreateStylesButton(extractedColors);
                } else {
                  console.log('UI.HTML: Button is now visible, clearing interval');
                  clearInterval(buttonCheckInterval);
                }
              }, 500); // Check every 500ms
              
              // Clear the interval after 5 seconds in any case
              setTimeout(() => {
                if (buttonCheckInterval) {
                  clearInterval(buttonCheckInterval);
                  buttonCheckInterval = null;
                }
              }, 5000);
            }
          } else if (message.type === 'error') {
            showMessage(message.message, 'error');
          } else if (message.type === 'progress') {
            showMessage(message.message, 'info');
          } else if (message.type === 'selection-state') {
            if (message.valid) {
              extractButton.disabled = false;
            } else {
              extractButton.disabled = true;
            }
          } else {
            console.log('UI.HTML: Unknown message type:', message.type);
          }
        } catch (error) {
          console.error('UI.HTML: Error processing message:', error);
          showMessage('An error occurred: ' + error.message, 'error');
        }
      };
    </script>
  </body>
</html>